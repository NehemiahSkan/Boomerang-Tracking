import cv2
import numpy as np
import matplotlib.pyplot as plt
import math
import os

class BoomerangTracker:
    
    def __init__(self, video_path):
        self.cap = cv2.VideoCapture(video_path)
        self.width = int(self.cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        self.height = int(self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        self.fps = int(self.cap.get(cv2.CAP_PROP_FPS))
        self.frame_count = int(self.cap.get(cv2.CAP_PROP_FRAME_COUNT))
        self.frames = []
        self.positions = []
        self.angles = []
        self.rect = None
    
    def __del__(self):
        self.cap.release()
        
    def preprocess(self, frame):
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
        lower_red = np.array([0, 150, 150])
        upper_red = np.array([10, 255, 255])
        mask1 = cv2.inRange(hsv, lower_red, upper_red)
        lower_red = np.array([170, 150, 150])
        upper_red = np.array([180, 255, 255])
        mask2 = cv2.inRange(hsv, lower_red, upper_red)
        mask = cv2.bitwise_or(mask1, mask2)
        return cv2.medianBlur(mask, 5)

    def get_boomerang_contours(self, frame):
        """
        Finds and returns the contours of the boomerang in the current frame.

        :param frame: The current frame as a numpy array.
        :return: A list of contours representing the boomerang, or None if the boomerang is not found.
        """
        # Apply the necessary image processing to the frame
        processed_frame = self.preprocess_frame(frame)

        # Detect the red color in the frame
        red_mask = self.detect_red(processed_frame)

        # Find the edges in the red color mask using Canny edge detection
        edges = cv2.Canny(red_mask, self.canny_threshold1, self.canny_threshold2)

        # Dilate the edges to make them thicker and connect any gaps
        dilated_edges = cv2.dilate(edges, self.dilate_kernel, iterations=self.dilate_iterations)

        # Find the contours in the dilated edges
        contours, hierarchy = cv2.findContours(dilated_edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Filter out any contours that are too small or too large to be the boomerang
        filtered_contours = [contour for contour in contours if self.min_contour_area < cv2.contourArea(contour) < self.max_contour_area]

        # Return the filtered contours or None if no boomerang was found
        if filtered_contours:
            return filtered_contours
        else:
            return None

    def get_angle(self):
        """Get the angle between the boomerang and the horizontal axis."""
        if self.boomerang_contour is None:
            raise ValueError("Boomerang contour not found.")
        # Get the bounding rectangle of the boomerang contour
        x, y, w, h = cv2.boundingRect(self.boomerang_contour)
        # Get the center of the bounding rectangle
        center_x = x + w / 2
        center_y = y + h / 2
        # Find the endpoints of the major axis of the bounding ellipse
        (major_axis_x, major_axis_y), (minor_axis_x, minor_axis_y), _ = cv2.fitEllipse(self.boomerang_contour)
        # Find the angle between the major axis and the horizontal axis
        angle = math.atan2(major_axis_y - center_y, major_axis_x - center_x)
        # Convert the angle to degrees
        angle_degrees = math.degrees(angle)
        return angle_degrees
    
    def track(self, frame):
        # Preprocess the frame to extract the red regions
        red_mask = self.preprocess(frame)

        # Find contours of red regions in the frame
        contours, hierarchy = cv2.findContours(red_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Find the contour that is most likely to be the boomerang
        boomerang_contour = self.get_boomerang_contours(frame)

        if boomerang_contour is None:
            return None, None

        # Get the angle of the boomerang contour
        angle = self.get_angle()

        # Draw the contour and angle on the frame
        cv2.drawContours(frame, [boomerang_contour], -1, (0, 255, 0), 2)
        cv2.putText(frame, f"Angle: {angle:.2f} degrees", (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

        return boomerang_contour, angle


    def plot_position(self):
        if len(self.positions) == 0:
            print("No positions to plot")
            return
        
        # Create a numpy array of positions
        positions = np.array(self.positions)
        
        # Create a figure and axis object
        fig, ax = plt.subplots(figsize=(12, 6))
        
        # Plot the x and y positions over time
        ax.plot(positions[:, 0], label="x position")
        ax.plot(positions[:, 1], label="y position")
        
        # Add title and axis labels
        ax.set_title("Boomerang Position over Time")
        ax.set_xlabel("Frame")
        ax.set_ylabel("Position (pixels)")
        
        # Add legend and grid
        ax.legend()
        ax.grid()
        
        # Show the plot
        plt.show()

    def plot_angle(self):
        """
        Plots the angle of the boomerang over time.
        """
        time = np.arange(len(self.angles)) / self.fps
        plt.plot(time, self.angles)
        plt.xlabel('Time (s)')
        plt.ylabel('Angle (degrees)')
        plt.title('Boomerang Angle vs Time')
        plt.show()

    def display_video(self):
        """
        Displays the original video with the boomerang contour and angle overlaid.
        """
        # Create a VideoWriter object to save the output video
        output_file = os.path.splitext(os.path.basename(self.video_path))[0] + "_output.mp4"
        fourcc = cv2.VideoWriter_fourcc(*"mp4v")
        writer = cv2.VideoWriter(output_file, fourcc, self.fps, (self.width, self.height), True)

        # Loop through each frame of the video
        for i, frame in enumerate(self.frames):
            # Get the boomerang contour and angle for the current frame
            boomerang_contour, angle = self.track(frame)

            # If the boomerang is found, add its position and angle to the list
            if boomerang_contour is not None:
                x, y, w, h = cv2.boundingRect(boomerang_contour)
                self.positions.append((x + w/2, y + h/2))
                self.angles.append(angle)

            # Plot the position and angle of the boomerang on the current frame
            self.plot_position(frame, i)
            self.plot_angle(frame, i)

            # Display the current frame with the boomerang contour and angle overlaid
            cv2.imshow("Video", frame)

            # Write the current frame to the output video
            writer.write(frame)

            # Exit if the 'q' key is pressed
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break

        # Release the video writer and destroy all windows
        writer.release()
        cv2.destroyAllWindows()


def detect_red(self, frame):
    """
    Detects red regions in the current frame.

    :param frame: The current frame as a numpy array.
    :return: A binary mask where white pixels represent red regions.
    """
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lower_red = np.array([0, 150, 150])
    upper_red = np.array([10, 255, 255])
    mask1 = cv2.inRange(hsv, lower_red, upper_red)
    lower_red = np.array([170, 150, 150])
    upper_red = np.array([180, 255, 255])
    mask2 = cv2.inRange(hsv, lower_red, upper_red)
    mask = cv2.bitwise_or(mask1, mask2)
    return mask

def get_largest_contour(contours):
    """
    Returns the largest contour from a list of contours.

    :param contours: A list of contours.
    :return: The largest contour, or None if the list is empty.
    """
    if not contours:
        return None
    return max(contours, key=cv2.contourArea)

def main():
    # Create an instance of BoomerangTracker with the path to the video file
    tracker = BoomerangTracker("DJI_0014.mp4")
    
    # Loop over the frames in the video
    for i in range(tracker.frame_count):
        # Read the next frame
        ret, frame = tracker.cap.read()

        # Check if the frame was read successfully
        if not ret:
            break

        # Track the boomerang in the current frame
        boomerang_contour, angle = tracker.track(frame)

        # If the boomerang was found, store its position and angle
        if boomerang_contour is not None:
            # Get the center of the bounding rectangle of the contour as the position
            x, y, w, h = cv2.boundingRect(boomerang_contour)
            center_x = x + w / 2
            center_y = y + h / 2
            position = [center_x, center_y]
            tracker.positions.append(position)
            tracker.angles.append(angle)

    # Plot the position of the boomerang over time
    tracker.plot_position()

    # Release the video capture object
    del tracker
